from typing import Optional, Tuple

from nptyping import Float, NDArray, Shape
from numpy.typing import DTypeLike

def fillpositive(
    xyz: NDArray[Shape["3"], Float], w2_thresh: Optional[float] = None
) -> NDArray[Shape["4"], Float]: ...
def quat2mat(q: NDArray[Shape["4"], Float]) -> NDArray[Shape["3, 3"], Float]: ...
def mat2quat(M: NDArray[Shape["3, 3"], Float]) -> NDArray[Shape["4"], Float]: ...
def qmult(
    q1: NDArray[Shape["4"], Float], q2: NDArray[Shape["4"], Float]
) -> NDArray[Shape["4"], Float]: ...
def qconjugate(q: NDArray[Shape["4"], Float]) -> NDArray[Shape["4"], Float]: ...
def qnorm(q: NDArray[Shape["4"], Float]) -> float: ...
def qisunit(q: NDArray[Shape["4"], Float]) -> bool: ...
def qinverse(q: NDArray[Shape["4"], Float]) -> NDArray[Shape["4"], Float]: ...
def qeye(dtype: DTypeLike) -> NDArray[Shape["4"], Float]: ...
def qexp(q: NDArray[Shape["4"], Float]) -> NDArray[Shape["4"], Float]: ...
def qlog(q: NDArray[Shape["4"], Float]) -> NDArray[Shape["4"], Float]: ...
def qpow(q: NDArray[Shape["4"], Float], n: float) -> NDArray[Shape["4"], Float]: ...
def rotate_vector(
    v: NDArray[Shape["3"], Float],
    q: NDArray[Shape["4"], Float],
    is_normalized: bool = True,
) -> NDArray[Shape["3"], Float]: ...
def nearly_equivalent(
    q1: NDArray[Shape["4"], Float],
    q2: NDArray[Shape["4"], Float],
    rtol: float = 1e-5,
    atol: float = 1e-8,
) -> bool: ...
def axangle2quat(
    vector: NDArray[Shape["3"], Float], theta: float, is_normalized: bool = False
) -> NDArray[Shape["4"], Float]: ...
def quat2axangle(
    quat: NDArray[Shape["4"], Float], identity_thresh: Optional[float] = None
) -> Tuple[float, NDArray[Shape["3"], Float]]: ...
